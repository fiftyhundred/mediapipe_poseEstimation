<!DOCTYPE html>
<html lang="ja">
<head>
    <title>mediapipe pose</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=9">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils_3d/control_utils_3d.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

</head>
<body>
<div class="container">
    <video class="input_video" muted crossorigin="anonymous" hidden></video>
    <canvas class="output_canvas" width="1280px" height="720px"></canvas>
    <div class="landmark-grid-container"></div>
    <div id="angle"></div>
    <button id="start">Start</button>
    <button id="fin">Fin</button>
</div>

<script type="module">
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext("2d");
    const angleElement = document.getElementById("angle");
    const landmarkContainer = document.getElementsByClassName('landmark-grid-container')[0];
    const grid = new LandmarkGrid(landmarkContainer,{
        connectionColor: 0xCCCCCC,
        definedColors:
            [{name: 'LEFT', value: 0xffa500}, {name: 'RIGHT', value: 0x00ffff}],
        range: 2,
        fitToGrid: true,
        labelSuffix: 'm',
        landmarkSize: 2,
        numCellsPerAxis: 4,
        showHidden: false,
        centered: true,
    });

    var starttime = new Date();
    var trainingTimer = new Date();
    var writing = "";
    var oncedownload = true;
    var cnt = 0;
    var trainingPattern = 0.0;
    var imageNode = [];//画像の座標保管


    const Image = {
      "upallow":document.createElement('img'),
      "downallow":document.createElement('img'),
    };

    Image["upallow"].src = 'image/upallow.png';
    Image["downallow"].src = 'image/downallow.png';

    const SE = {
      0:new Audio('SE/start.mp3'),
      1:new Audio('SE/1.mp3'),
      2:new Audio('SE/2.mp3'),
      3:new Audio('SE/3.mp3'),
      4:new Audio('SE/4.mp3'),
      5:new Audio('SE/5.mp3'),
      6:new Audio('SE/6.mp3'),
      7:new Audio('SE/7.mp3'),
      8:new Audio('SE/8.mp3'),
      9:new Audio('SE/right.mp3'),
      10:new Audio('SE/left.mp3'),
      11:new Audio('SE/break.mp3'),
    };

    //取得したい角度のポイント
    //もちろん真ん中が原点となるポイントになるように書いてね
    //関節スコアの参照 -> https://google.github.io/mediapipe/solutions/pose.html#pose-landmark-model-blazepose-ghum-3d
    const needVector = {
        // "rightUde":[12,14,16],
        // "leftUde":[11,13,15],
        "rightElbow":[12,14,16],
        "leftElbow":[11,13,15],
    };

    function makeVector(pose1,pose2){//始点,終点
      const vector1 = {
          x:Math.round((pose2.x-pose1.x)*1000000)/1000000,
          y:Math.round((pose2.y-pose1.y)*1000000)/1000000,
          z:Math.round((pose2.z-pose1.z)*1000000)/1000000,
          visibility:Math.min(pose1.visibility,pose2.visibility),
      }
      return vector1;
    }


    //角度の計算
    function calcAngle(pose1,pose2,pose3){
        // please learn here -> https://npm.runkit.com/%40mediapipe%2Fpose

        const vector1 = {
            x:Math.round((pose1.x-pose2.x)*1000000)/1000000,
            y:Math.round((pose1.y-pose2.y)*1000000)/1000000,
            z:Math.round((pose1.z-pose2.z)*1000000)/1000000,
            visibility:Math.min(pose1.visibility,pose2.visibility),
        }
        const vector2 = {
            x:Math.round((pose3.x-pose2.x)*1000000)/1000000,
            y:Math.round((pose3.y-pose2.y)*1000000)/1000000,
            z:Math.round((pose3.z-pose2.z)*1000000)/1000000,
            visibility:Math.min(pose3.visibility,pose2.visibility),
        }
        //console.log("arrived vector",vector1,vector2)
        return {
            angle: Math.acos((vector1.x * vector2.x + vector1.y * vector2.y + vector1.z * vector2.z) / ( Math.sqrt(vector1.x**2 + vector1.y**2 + vector1.z**2) * Math.sqrt(vector2.x**2 + vector2.y**2 + vector2.z**2))) * 180 / Math.PI,
            visibility: Math.min(vector1.visibility, vector2.visibility),
            "vector1":vector1,
            "vector2":vector2,

        };

    }

    function facehide(canvasElement, img, nose, left_ear, right_ear) {
            let width = canvasElement.width * Math.abs(left_ear.x - right_ear.x) * 3;
            let height = width * Math.round(img.height / img.width);
            let x = Math.round(nose.x * canvasElement.width) - (width / 2);
            let y = Math.round(nose.y * canvasElement.height) - (height / 2);

            return {
                'x': x,
                'y': y,
                'width': width,
                'height': height,
            };
      }

      function calcWrist(wrist,elbow,shoulder){
        var ew = makeVector(elbow,wrist);
        var es = makeVector(elbow,shoulder);
        var sw = makeVector(shoulder,wrist);
        var ewLength = Math.sqrt(ew.x**2 + ew.y**2 + ew.z**2);
        var esLength = Math.sqrt(es.x**2 + es.y**2 + es.z**2);
        var swLength = Math.sqrt(sw.x**2 + sw.y**2 + sw.z**2);
        var swLengthFuture = Math.sqrt(ewLength**2+esLength**2-2*ewLength*esLength*Math.cos(140 / 180 * Math.PI));

        return {x:wrist.x,y:wrist.y-swLengthFuture};
      }


        //11/15
        const cells = []
        const items = 6;
        function cellMake() {
            //タイムスタンプと共に角度とどの信頼度をセルにする
            const cellTag = {
                0: "時刻（日本）",
                1: "leftAngle",
                2: "rightAngle",
                3: "Angle",
                4: "visibility(left)",
                5: "visibility(right)",
            };
            console.log(cellTag)
            cells.push(cellTag);

        }

        function cellUpdate(leftAngle, rightAngle) {
            //cellMakeにデータをぶち込む
            const timeStamp = () => {
                const today = new Date();
                const yy = ('0000' + today.getFullYear()).slice(-4);
                const mo = ('00' + (today.getMonth() + 1)).slice(-2);
                const dd = ('00' + today.getDate()).slice(-2);
                const hh = ('00' + today.getHours()).slice(-2);
                const mi = ('00' + today.getMinutes()).slice(-2);
                const ss = ('00' + today.getSeconds()).slice(-2);
                const ms = ('000' + today.getMilliseconds()).slice(-3);

                return yy + mo + dd + hh + mi + ss + ms;
            }

            const cell = {
                0: timeStamp(),
                1: leftAngle.angle,
                2: rightAngle.angle,
                3: (leftAngle.angle + rightAngle.angle) / 2,
                4: leftAngle.visibility,
                5: rightAngle.visibility,
            }
            cells.push(cell);

        }

        function cellDownload(items, cells) {
            //cellをローカルに保存
            let str = "";
            for (let i = 0; i < cells.length; i++) {
                let nowCell = cells[i];
                for (let j = 0; j < items; j++) {
                    str += nowCell[j];
                    if (j === (items - 1)) {
                        str += "\n";
                    } else {
                        str += ",";
                    }
                }
            }
            let blob = new Blob([str], { type: "text/csv" }); //配列に上記の文字列(str)を設定
            let link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = "data.csv";
            link.click();
        }

        function cellDrive(items, cells) {
            let str = "";
            for (let i = 0; i < cells.length; i++) {
                let nowCell = cells[i];
                for (let j = 0; j < items; j++) {
                    str += nowCell[j];
                    if (j === (items - 1)) {
                        str += "\n";
                    } else {
                        str += ",";
                    }
                }
            }

            // (1)XMLHttpRequestオブジェクトを作成
            var xmlHttpRequest = new XMLHttpRequest();
            var formData = new FormData();

            formData.append("str", str);
            formData.append("user", Object.fromEntries(new URLSearchParams(window.location.search)).user)

            // (2)onreadystatechangeイベントで処理の状況変化を監視
            xmlHttpRequest.onreadystatechange = function () {
                if (this.readyState === 4 && this.status === 200) {
                    console.log("success!");
                }
            }

            // (3)HTTPのGETメソッドとアクセスする場所を指定
            xmlHttpRequest.open('POST', 'https://script.google.com/macros/s/AKfycbzu6jjvgWIkFBZNyB8DS4w31KnWx8TAXxOWhYUt7PmVvGvitHD_IZ1mh8IGVJz20Arw/exec', true);
            //xmlHttpRequest.responseType = "text";
            // (4)HTTPリクエストを送信
            xmlHttpRequest.send(formData);
        }

        //ボタンを押したらCSV出力
        const finButton = document.getElementById('fin');
        finButton.addEventListener('click', function () {
            //cellDrive(items, cells);//Driveにアップロード
            cellDownload(items,cells);//localにダウンロード
            const user = Object.fromEntries(new URLSearchParams(window.location.search)).user.split(",");
            console.log(user);
        });

        //training設定
        function startTraining(pattern){
          switch (pattern) {
            case 2.0:
              const node = [-1,2,3,4,5,6,7,8,11,-2];
              cnt = -1;
              var timer1 = setInterval(function(){playTrainingMusic(node,++cnt);playTrainingImage(node,cnt,pattern);},1000);
              setTimeout(function(){ clearInterval(timer1);},(node.length*4-2)*1000);
              break;
            default:
              break;
          }
        }

        //音声再生
        function playTrainingMusic(node,cnt){
          var items = node.length;
          if (node[cnt%items]==-1){
            SE[cnt/items+1].currentTime = 0;
            SE[cnt/items+1].play();
            //console.log(cnt/items+1);
          }else if(node[cnt%items]==-2){
            //何もしない
          }else{
            SE[node[cnt%items]].currentTime = 0;
            SE[node[cnt%items]].play();
            //console.log(node[cnt%items]);
          }

        }

        //画像設定
        function playTrainingImage(node,cnt,pattern){
          var items = node.length;
          if(node[cnt%items]==-1){
            trainingPattern = pattern;
          }
        }

        function startTrainingImage(pattern){
          setTimeout(function(){ trainingPattern = pattern; },1000);
          setTimeout(function(){ trainingPattern = 0.0; },38*1000);
        }

        function drawTrainingImage(pL){
          switch (trainingPattern) {
            case 2.0:
              //canvasCtx.drawImage(Image["upallow"],pL[POSE_LANDMARKS.RIGHT_WRIST].x*canvasElement.width,pL[POSE_LANDMARKS.RIGHT_WRIST].y*canvasElement.height,50,50);
              //canvasCtx.drawImage(Image["upallow"],pL[POSE_LANDMARKS.LEFT_WRIST].x*canvasElement.width,pL[POSE_LANDMARKS.LEFT_WRIST].y*canvasElement.height,50,50);
              imageNode.push({x:pL[POSE_LANDMARKS.RIGHT_WRIST].x*canvasElement.width,y:pL[POSE_LANDMARKS.RIGHT_WRIST].y*canvasElement.height});
              imageNode.push({x:pL[POSE_LANDMARKS.LEFT_WRIST].x*canvasElement.width,y:pL[POSE_LANDMARKS.LEFT_WRIST].y*canvasElement.height});
              var rightElbowFuture = calcWrist(pL[POSE_LANDMARKS.RIGHT_WRIST],pL[POSE_LANDMARKS.RIGHT_ELBOW],pL[POSE_LANDMARKS.RIGHT_SHOULDER]);
              var leftElbowFuture = calcWrist(pL[POSE_LANDMARKS.LEFT_WRIST],pL[POSE_LANDMARKS.LEFT_ELBOW],pL[POSE_LANDMARKS.LEFT_SHOULDER]);
              imageNode.push({x:rightElbowFuture.x*canvasElement.width,y:rightElbowFuture.y*canvasElement.height});
              imageNode.push({x:leftElbowFuture.x*canvasElement.width,y:leftElbowFuture.y*canvasElement.height});
              trainingPattern = 2.1;
              trainingTimer = new Date();

              break;
            case 2.1:
              var now = new Date();
              var rate = (now -trainingTimer)/4000;
              if(rate<=1.0){
                canvasCtx.drawImage(Image["upallow"],imageNode[0].x-25,imageNode[0].y-(imageNode[0].y-imageNode[2].y)*rate-25,50,(imageNode[0].y-imageNode[2].y)*rate);
                canvasCtx.drawImage(Image["upallow"],imageNode[1].x-25,imageNode[1].y-(imageNode[1].y-imageNode[3].y)*rate-25,50,(imageNode[1].y-imageNode[3].y)*rate);
              }else{
                /*rate = 1.0;
                canvasCtx.drawImage(Image["upallow"],imageNode[2].x+25,imageNode[0].y-(imageNode[2].y-imageNode[0].y)*rate+25,50,(imageNode[2].y-imageNode[0].y)*rate);
                canvasCtx.drawImage(Image["upallow"],imageNode[3].x+25,imageNode[1].y-(imageNode[3].y-imageNode[1].y)*rate+25,50,(imageNode[3].y-imageNode[1].y)*rate);
                */
                trainingTimer = new Date();
                trainingPattern = 2.2;
                imageNode.push({x:pL[POSE_LANDMARKS.RIGHT_WRIST].x*canvasElement.width,y:pL[POSE_LANDMARKS.RIGHT_WRIST].y*canvasElement.height});
                imageNode.push({x:pL[POSE_LANDMARKS.LEFT_WRIST].x*canvasElement.width,y:pL[POSE_LANDMARKS.LEFT_WRIST].y*canvasElement.height});
                console.log("2.1to2.2");
              }
              break;
            case 2.2:
              var now = new Date();
              var rate = (now -trainingTimer)/4000;
              if(rate<=1.0){
                canvasCtx.drawImage(Image["downallow"],imageNode[4].x-25,imageNode[4].y-25,50,(imageNode[0].y-imageNode[4].y)*rate);
                canvasCtx.drawImage(Image["downallow"],imageNode[5].x-25,imageNode[5].y-25,50,(imageNode[1].y-imageNode[5].y)*rate);
              }else{
                /*rate = 1.0;
                canvasCtx.drawImage(Image["upallow"],imageNode[2].x+25,imageNode[0].y-(imageNode[2].y-imageNode[0].y)*rate+25,50,(imageNode[2].y-imageNode[0].y)*rate);
                canvasCtx.drawImage(Image["upallow"],imageNode[3].x+25,imageNode[1].y-(imageNode[3].y-imageNode[1].y)*rate+25,50,(imageNode[3].y-imageNode[1].y)*rate);
                */
                trainingTimer = new Date();
                trainingPattern = 0.0;
                imageNode = [];
              }

              break;
            default:
              break;
          }
        }

        //startボタンで運動開始
        const startButton = document.getElementById('start');
        startButton.addEventListener('click', function () {
          SE[0].currentTime = 0;
          SE[0].play();
          setTimeout(startTraining,3000,2.0);
        });

/*function download_txt(file_name, data) {
    const blob = new Blob([data], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    document.body.appendChild(a);
    a.download = file_name;
    a.href = url;
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
}*/

    function onResults(results) {
        if (!results.poseLandmarks) {
            grid.updateLandmarks([]);
            return;
        }

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        // canvasCtx.drawImage(results.segmentationMask, 0, 0,
        //     canvasElement.width, canvasElement.height);

        // Only overwrite existing pixels.
        canvasCtx.globalCompositeOperation = 'source-in';
        canvasCtx.fillStyle = '#00FF00';
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        // Only overwrite missing pixels.
        canvasCtx.globalCompositeOperation = 'destination-atop';
        canvasCtx.drawImage(
            results.image, 0, 0, canvasElement.width, canvasElement.height);

        canvasCtx.globalCompositeOperation = 'source-over';
        drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
            {color: '#00FF00', lineWidth: 4});
        drawLandmarks(canvasCtx, Object.values(POSE_LANDMARKS_NEUTRAL)
                .map(index => results.poseLandmarks[index]),
            {color: '#00FF00', lineWidth: 2});
        drawLandmarks(canvasCtx, Object.values(POSE_LANDMARKS_LEFT)
                .map(index => results.poseLandmarks[index]),
            {color: '#FF0000', lineWidth: 2});
        drawLandmarks(canvasCtx, Object.values(POSE_LANDMARKS_RIGHT)
                .map(index => results.poseLandmarks[index]),
            {color: '#0000FF', lineWidth: 2});

        //ここで描写
        drawTrainingImage(results.poseLandmarks);

        canvasCtx.restore();

        if(results.poseWorldLandmarks){
            const resultAngle ={};
            var now = new Date();
            var sec = (now.getTime() - starttime.getTime())/1000;

            var resulttxt=String(sec);

            /*resulttxt = resulttxt+ ",rightShoulder," + String(results.poseWorldLandmarks[12].x) + ","+String(results.poseWorldLandmarks[12].y);
            resulttxt = resulttxt+ ",leftShoulder," + String(results.poseWorldLandmarks[11].x) + ","+String(results.poseWorldLandmarks[11].y);
            resulttxt = resulttxt+ ",rightHip," + String(results.poseWorldLandmarks[24].x) + ","+String(results.poseWorldLandmarks[24].y);
            resulttxt = resulttxt+ ",leftHip," + String(results.poseWorldLandmarks[23].x) + ","+String(results.poseWorldLandmarks[23].y);
            */

            for (let key in needVector){
                resultAngle[key] = calcAngle(results.poseWorldLandmarks[needVector[key][0]],results.poseWorldLandmarks[needVector[key][1]],results.poseWorldLandmarks[needVector[key][2]]);
                resulttxt = resulttxt+ "," + String(key) + "," + String(resultAngle[key].angle) + "," + String(resultAngle[key].visibility);
            }
            angleElement.innerHTML = resulttxt;//JSON.stringify(resultAngle);
            cellUpdate(resultAngle.leftElbow, resultAngle.rightElbow);
        }

        grid.updateLandmarks(results.poseWorldLandmarks);
    }

    const pose = new Pose({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
        }});
    pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: true,
        smoothSegmentation: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    pose.onResults(onResults);

    /*async function onFrame() {
      if (videoElement.ended && oncedownload){
        //download_txt("training2_0.csv", writing);
        oncedownload = false;
      }
      if (!videoElement.paused && !videoElement.ended) {
        await pose.send({
          image: videoElement
        });
      // https://stackoverflow.com/questions/65144038/how-to-use-requestanimationframe-with-promise
        await new Promise(requestAnimationFrame);
        onFrame();
      } else
        setTimeout(onFrame, 500);
    }

    //videoElement.src = "./0_2.mp4";
    videoElement.onloadeddata = (evt) => {
      let video = evt.target;
      canvasElement.width = video.videoWidth;
      canvasElement.height = video.videoHeight;
      videoElement.play();
      onFrame();
    }*/
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await pose.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });
    camera.start();
    cellMake();
</script>
</body>
</html>
